#include <gmpxx.h>#include <vector>#include <cstddef>#include <cuda_runtime.h>#include <cstdio>#include <getopt.h>#include <cstring>#include "cump/cump.cuh"#include "clock.h"#include "mpf_extra.h"// Row major indexing__host__ __device__ size_t RM(size_t row, size_t col, size_t width){    return row * width + col;}using cump::mpf_array_t;__global__ void cump_matmul_kernel(const mpf_array_t __restrict__ A,			     const mpf_array_t __restrict__ B,			     mpf_array_t __restrict__ C,			     mpf_array_t __restrict__ Temp,			     int N1, int N2, int N3){    using namespace cump;    size_t row = blockIdx.y * blockDim.y + threadIdx.y;    size_t col = blockIdx.x * blockDim.x + threadIdx.x;    if (row >= N1 || col >= N3)	return;    //    Can't do this:     //    mpf_set_d(C[RM(row, col, N3)], 0.0);    for (size_t k = 0; k < N2; k++) {	mpf_mul(Temp[RM(row, col, N3)], A[RM(row, k, N2)], B[RM(k, col,  N3)]);	mpf_add(C[RM(row, col, N3)], C[RM(row, col, N3)], Temp[RM(row, col, N3)]);    }}void matmul_eval_cumpf(mpf_t *A,			 mpf_t *B,			 mpf_t *Cref,			 size_t N1, size_t N2, size_t N3,			 int trials, int prec, bool csv_only){    size_t sizeA = N1 * N2;    size_t sizeB = N2 * N3;    size_t sizeC = N1 * N3;    mpf_t *C = uniform_array_mpf(sizeC, 0.0, 0.0, 0.0, 1);    cumpf_set_default_prec(prec);    cumpf_array_t cA, cB, cC, cTemp, cZ;    cumpf_array_init_set_mpf (cA, A, sizeA);    cumpf_array_init_set_mpf (cB, B, sizeB);    cumpf_array_init(cC, sizeC);    cumpf_array_init(cTemp, sizeC);    // All zeros    cumpf_array_init_set_mpf(cZ, C, sizeC);    // Launch kernel    size_t bsize = 16;    dim3 block(bsize, bsize);    dim3 grid((N3 + bsize - 1) / bsize,              (N1 + bsize - 1) / bsize);    double ppo = 1e10;    for (int t = 0; t < trials; t++) {	start_timer();	// Perform multiplication	cumpf_array_set(cC, cZ, sizeC);	cump_matmul_kernel<<<grid, block>>>(cA, cB, cC, cTemp, N1, N2, N3);	cudaDeviceSynchronize();	double this_ppo = 1e12 * get_timer() / (2 * N1 * N2 * N3);	if (this_ppo < ppo)	    ppo = this_ppo;    }    // Copy result back    mpf_array_set_cumpf(C, cC, sizeC);    cumpf_array_clear(cA);    cumpf_array_clear(cB);    cumpf_array_clear(cC);    cumpf_array_clear(cTemp);    cumpf_array_clear(cZ);    double min_dp = 1e6;    size_t min_i = 0;    size_t min_j = 0;	    for (size_t i = 0; i < N1; ++i) {        for (size_t j = 0; j < N3; ++j) {	    double dp = digit_precision(C[RM(i, j, N3)], Cref[RM(i, j, N3)]);	    if (dp < min_dp) {		min_i = i;		min_j = j;		min_dp = dp;	    }        }    }    if (csv_only) {	printf("cump%d,%.1f,%.4f\n", prec, min_dp, ppo);    } else {	gmp_printf("MM<cump%d>(%zd,%zd,%zd).  PPO = %.4f.  Min DP = %.1f (i = %zd, j = %zd, %.20Fg, %.20Fg)\n",		   prec, N1, N2, N3, ppo, min_dp, min_i, min_j,		   C[RM(min_i, min_j, N3)], Cref[RM(min_i, min_j, N3)]);    }    for (int i = 0; i < sizeC; i++)	mpf_clear(C[i]);    free(C);}/* Data Generation */void setup_mpf_matrices(size_t N1, size_t N2, size_t N3,			int prec,			mpf_t min,			mpf_t max,			unsigned long seed,			mpf_t **A,			mpf_t **B,			mpf_t **Cref){    // Set precision for all newly created mpf_t objects    mpf_set_default_prec(prec);    size_t sizeA = N1 * N2;    size_t sizeB = N2 * N3;    size_t sizeC = N1 * N3;    *A = uniform_array_mpf(sizeA, mpf_get_d(min), mpf_get_d(max), 0.0, seed);    *B = uniform_array_mpf(sizeB, mpf_get_d(min), mpf_get_d(max), 0.0, seed);    *Cref = uniform_array_mpf(sizeC, 0.0, 0.0, 0.0, seed);    mpf_t temp;    mpf_init(temp);    for (int row = 0; row < N1; row++) {	for (int col = 0; col < N3; col++) {	    mpf_set_d((*Cref)[RM(row, col, N3)], 0.0);	    for (int k = 0; k < N2; k++) {		mpf_mul(temp, (*A)[RM(row, k, N2)], (*B)[RM(k, col, N3)]);		mpf_add((*Cref)[RM(row, col, N3)], (*Cref)[RM(row, col, N3)], temp);	    }	}    }    mpf_clear(temp);}void usage(char *name) {    fprintf(stderr, "Usage: %s [-h] [-q] [-n CNT] [-s SEED] [-m DMIN] [-M DMAX] [-t TRIALS]\n", name);    fprintf(stderr, "   -h      Print this message\n");    fprintf(stderr, "   -q      Only generate CSV\n");    fprintf(stderr, "   -n CNT  Data size\n");     fprintf(stderr, "   -s SEED Set random seed\n");    fprintf(stderr, "   -m MIN  Data minimum (Power of 10 when exponential)\n");    fprintf(stderr, "   -M MAX  Data maximum (Power of 10 when exponential)\n");    fprintf(stderr, "   -t TRI  Specify number of runs for each benchmark\n");}#define MAX_CUMPF  11#define MAX_PREC MAX_CUMPF * 64 + 64int main(int argc, char *argv[]) {    size_t N = 1000;    bool csv_only = false;    unsigned long seed = 123;#if 0    bool exp = false;#endif    int trials = 3;    int max_prec = MAX_PREC;    mpf_t minval;    mpf_init2(minval, max_prec);    mpf_set_d(minval, 0.0);    mpf_t maxval;    mpf_init2(maxval, max_prec);    mpf_set_d(maxval, 1.0);    int c;    while ((c = getopt(argc, argv, "hqn:s:m:M:t:")) != -1) {	switch(c) {	case 'h':	    usage(argv[0]);	    return 0;	    break;	case 'q':	    csv_only = true;	    break;	case 'n':	    N = atoi(optarg);	    break;	case 's':	    seed = strtoul(optarg, (char **) NULL, 10);	    break;	case 'm':	    gmp_sscanf(optarg, "%Ff", minval);	    break;	case 'M':	    gmp_sscanf(optarg, "%Ff", maxval);	    break;	case 't':	    trials = atoi(optarg);	    break;	}    }    mpf_t *A, *B, *Cref;    size_t N1, N2, N3;    N1 = N2 = N3 = N;    if (csv_only) {	printf("Data,dp,ps\n");    } else {	gmp_printf("Running with N1 = N2 = N3 = %zd, min = %.10Fg max = %.10Fg\n",		   N, minval, maxval);    }    mpf_settings_init(max_prec, seed);    setup_mpf_matrices(N1, N2, N3, max_prec,				 minval, maxval,				 seed, &A, &B, &Cref);    for (int i = 1; i <= MAX_CUMPF; i++) {	char tbuf[30];	int prec = i*64;	matmul_eval_cumpf(A, B, Cref, N1, N2, N3, trials, prec, csv_only);	snprintf(tbuf, 30, "MPF%d", prec);    }    return 0;}